# ES5

![es5 知识体系](./img/es5.svg)

## 原型
原型链在 JS 语言规范里面叫做 `[[Prototype]]`，规范并没有要求实现这个字段。但实际上所有浏览器，甚至连 Node 服务端都实现了，而且都叫做 `__proto__`。

“读”操作会顺着原型链一直找，“写”操作只会写当前对象不会覆盖原型链上的对象。

### 字段遍历
`for...in` 会将原型链上的属性一起枚举，可以配合 `hasOwnProperty` 实现只枚举自己的属性，另外设置了 `enumerable:false` 的属性不会被枚举。

除了 `for...in` 以外的操作，例如 `Object.keys`、`Object.values`，都会忽略继承的属性。

### F.prototype
`F.prototype` 和 `new` 是配合使用的，他们两跟原型没啥关系，只是为了让我们能够用类似 Java 的语法来控制原型链。

这是 JS 语言比较坑的知识点，学习的时候要注意：
- 就算不用 `new` 关键字，我们也可以实现同样的功能
- `new` 和 `F.prototype` 是妥协的产物

## 函数
### IIFE
函数表达式可以立即执行，但函数声明不可以。为了让 JS 引擎能在语法上区分二者，我们有几种办法：
- 加括号：`(function(){ ... })(a, b)`
- 加括号：`(function(){ ... }(a, b))`
- 在前面加任意一元操作符：`+function(){ ... }(a, b)`
- 这样写会识别为函数声明，导致报错：`function(){ ... }(a, b)`

### this
在 Java 等语言中，`this` 的指向取决于函数定义的位置，但是在 JavaScript 中，`this` 的指向还取决于函数调用的方式。共有 4 种调用方式：
- 作为函数 (function) 直接调用，这时候指向 window 对象，但开启 `'use strict'` 之后指向 undefined
- 作为方法 (method) 调用
- 作为构造器，通过 `new` 调用
- 通过 `apply` 或者 `call` 调用

即便是经验丰富的工程师也会用错，所以 ES6 的箭头函数简化了 `this` 的规则。
