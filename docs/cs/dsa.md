# 数据结构与算法

## 哈希、哈希表
应用场景：
- 加密
- 索引
- 缓存

解决哈希冲突：
- 开放寻址法包括：线性探测法、再散列法
- 拉链法

哈希函数的实现：
- 直接定址法
- 除留余数法，选一个较大的素数作为除数
- 一致性哈希

### 扩容
当元素数量大于哈希表的体积时，开放寻址法无法工作，此时必须对哈希表进行扩容。当元素数量远大于哈希表体积时，拉链法会退化成为链表，此时建议对哈希表进行扩容。

扩容意味着元素要重新分布，这就需要进行再哈希 (re-hash)，再哈希要耗费大量时间来移动几乎所有元素，移动过程中哈希表无法工作。在分布式系统中，当服务器扩容时，路由算法无法工作，导致系统无法提供服务。一致性哈希可以缓解这个问题。

### 元素删除
当需要删除元素的时候，开放寻址法不能直接删除元素，而是要做特殊处理 (例如放置一个删除的标记)。

### 语言内置的哈希表
哈希表常用操作：
- `set(k, v)`
- `get(k)`
- `delete(k)`
- `size()`
- 检查 key 是否存在
- `keys()` 获取所有 key
- `values()` 获取所有 value
- `entries()` 获取所有键值对

[java.util.Map](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html) 是 Java 内置的一个接口，最常见的实现是：`HashMap`、`TreeMap`。在 Java 中，每个对象都有 hashCode() 方法，自定义的数据类型可以根据业务特点重写 `Object.hashCode()` 方法。

JavaScript 的对象本身就可以当做哈希表使用：`var hash = {};`，ES6 新增了一个专门做哈希表的类：`var hash = new Map();`

Python 自带的 `dict` 就是哈希表。
- 初始化: `hash = dict()`
- 使用字面量初始化: `hash = {}`
- 添加元素: `hash['a'] = 123`
- 删除元素: `del hash['a']`
- 判断 key 是否存在: `'a' in hash`
- 获取哈希表的大小: `len(hash)`

### 练习题
利用内置的哈希表实现缓存：
- [力扣 1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

## 二叉树

### 构造二叉搜索树
