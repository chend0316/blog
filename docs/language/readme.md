# 编程语言
## 语言理论
### 强类型语言和弱类型语言
1974年，Liskov和Zilles提出强类型语言的概念

> 在强类型语言中，当一个对象从调用函数传递到被调用函数时，其类型必须与被调用函数中声明的类型兼容

但是这个解释很泛，也不容易理解，后人给出了更具体的解释：在强类型语言中，变量的类型不能被改变。

例如Java是强类型语言：
```java
class C {
    public static void main(String[] args) {
        int x =1;
        char z = 'a';
        x = z;  // 这里Java会将'a'的ASCII码传递给x，x的类型仍然是int
    }
}
```

### 静态类型语言和动态类型语言
静态类型语言：在编译阶段确定所有变量的类型

动态类型语言：在运行阶段确定所有变量的类型

```js
class C {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

function add(a, b) {  // js在编译的时候并不知道a和b的类型
    return a.x + a.y + b.x + b.y;
}
```

```cpp
class C {
public:
    int x;
    int y;
}

int add(C a, C b) {  // c++在编译的时候就知道a和b的类型
    return a.x + a.y + b.x + b.y;
}
```

静态类型语言在编译阶段就能够确定属性的偏移量：
- 编译阶段就确定了属性的偏移量
- 运行阶段直接根据偏移量来访问
- 所有对象共享相同的偏移量

而动态类型语言编译时无法确定属性偏移量：
- 在运行时才知道偏移量
- 需要额外空间维护属性名和偏移量之间的映射
- 每个对象的偏移量都不相同

## 语言特性
| 特性 | C++ | Java | Py3 | ES5 | ES6 | TS |
| --- | --- | --- | --- | --- | --- | --- |
| foreach循环 |  |  |Y|||  |
| foreach遍历Unicode字符串 |  |  | Y | N | Y |  |
| 模板字符串 |  |  | | N | Y |  |
| 模板字符串内嵌表达式 |  |  | | - | Y |  |
| 2进制整数字面量 |  |  ||||  |
| 类型别名 | Y |  |||| Y |
| 枚举类型 | Y |  ||N|N| Y |
| 枚举作用域 |  |  ||||  |
| 静态类型：类型推断 | Y |  |||| Y |
| 内联函数 | Y |  ||||  |
| 输入输出参数 | Y |  |N|||  |
| 匿名函数（复杂Lambda） |  |  |N|Y|Y| Y |
| 可变参数 |  |  ||Y|Y|  |
| 默认参数 | Y |  |Y|N|| Y |
| 闭包 |  |  |Y|Y|Y| Y |
| 运算符重载 | Y |  |Y|N|N| N |
|  |  |  ||||  |

### foreach循环

### foreach遍历Unicode字符串

### 模板字符串

### 模板字符串内嵌表达式

### 2进制整数字面量

### 类型别名

类型别名是对类型的一种抽象。

在C中通过typedef为已有类型定义别名：`typedef int ID;`

在C++中使用using：`using ID = int;`

在TypeScript中：`type ID = int;`

### 枚举类型

枚举可以创建出一个新的数据类型，它的取值范围以及可执行的操作都会受限。

枚举元素是常量，有默认值（从0开始）

C++：`enum Color { RED, GREEN, YELLOW }`

### 静态类型：类型推断

C++在变量声明的时候可以使用auto关键字：`auto val = val1 + val2;`

C++的decltype更强大，其功能和auto形成互补，可以推断出一个变量的类型：`int foo(decltype(val) arg);`

### 输入输出参数

C可以通过传递指针实现

C++通过引用传递实现

Python因为支持函数多返回值，也不需要支持输入输出参数

题外话：更多时候C++传引用不是为了双向传递，而是避免大对象值传递消耗太多内存，这时使用`const int *a`可以避免不小心修改实参。

### 匿名函数

Python被缩进式语法给坑了，无法支持复杂的Lambda表达式，这也导致Python难以实现函数式编程。

### 可变参数

### 默认参数

TS甚至不要求默认参数的位置出现在最后，怎么做到的呢？这得益于JS的`undefined`的特殊语义，这其实是JS的缺点，但是因祸得福吧。

### 闭包

### 运算符重载

Python支持运算符重载，所以有时判等需要用`a is b`，而不是用`a == b`。

## 面向对象语言特性

| 特性         | C++  | Java | Py3  | ES5  | ES6  | TS   |
| ------------ | ---- | ---- | ---- | ---- | ---- | ---- |
| 继承         |      |      |      |      |      |      |
| 多态         | Y    | Y    |      |      |      | Y    |
| 虚基类       | Y    |      |      | N    | N    | Y    |
| 多重继承     |      |      |      |      |      |      |
| 接口         |      |      |      |      |      |      |
| 接口继承接口 |      |      |      |      |      |      |
| 接口继承类   |      |      |      |      |      |      |
|              |      |      |      |      |      |      |
|              |      |      |      |      |      |      |



## 编程范式

### 函数式编程

- 实现一个memorize函数，加快汉诺塔算法、斐波那契数列算法
- 实现函数防抖、函数节流

## 语言实现细节

### 参数传递

Python中，函数参数只有引用传递，没有值传递，那么参数传int的时候不怕函数修改实参吗？

### 多线程

Python有多种实现，其官方实现的多线程能力很差，因为Python有一个全局解释器锁，导致每一行Python代码都是竞争资源。

