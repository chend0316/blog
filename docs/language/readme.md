# 编程语言
## 语言理论
### 强类型语言和弱类型语言
1974年，Liskov和Zilles提出强类型语言的概念

> 在强类型语言中，当一个对象从调用函数传递到被调用函数时，其类型必须与被调用函数中声明的类型兼容

但是这个解释很泛，也不容易理解，后人给出了更具体的解释：在强类型语言中，变量的类型不能被改变。

例如Java是强类型语言：
```java
class C {
    public static void main(String[] args) {
        int x =1;
        char z = 'a';
        x = z;  // 这里Java会将'a'的ASCII码传递给x，x的类型仍然是int
    }
}
```

### 静态类型语言和动态类型语言
静态类型语言：在编译阶段确定所有变量的类型

动态类型语言：在运行阶段确定所有变量的类型

```js
class C {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

function add(a, b) {  // js在编译的时候并不知道a和b的类型
    return a.x + a.y + b.x + b.y;
}
```

```cpp
class C {
public:
    int x;
    int y;
}

int add(C a, C b) {  // c++在编译的时候就知道a和b的类型
    return a.x + a.y + b.x + b.y;
}
```

静态类型语言在编译阶段就能够确定属性的偏移量：
- 编译阶段就确定了属性的偏移量
- 运行阶段直接根据偏移量来访问
- 所有对象共享相同的偏移量

而动态类型语言编译时无法确定属性偏移量：
- 在运行时才知道偏移量
- 需要额外空间维护属性名和偏移量之间的映射
- 每个对象的偏移量都不相同

## 语言特性
| 特性 | Python2 | Python3 | ES5 | ES6 |
| --- | --- | --- | --- | --- |
| foreach遍历Unicode字符串 | N | Y | N | Y |
| 模板字符串 | | | N | Y |
| 模板字符串内嵌表达式 | | | - | Y |
| 2进制整数字面量 |

### foreach遍历Unicode字符串

### 模板字符串

### 模板字符串内嵌表达式

### 2进制整数字面量
