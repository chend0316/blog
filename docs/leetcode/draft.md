# 零散知识

## 二叉树

### 最近公共祖先

注意[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)节点只有left、right指针，没有parent指针。

题目特性：

- 根节点一定是解，但不是最优解
- 最优解存在且唯一
- 必须掌握左右孩子信息后才能对当前节点做出决策，因此要用后序遍历

采用后序遍历会先遇到最优解，后遇到次优解，所以找到第一个解就可以停下来了。递归（不像迭代）是停不下来的，因此我们要避免次优解覆盖最优解的可能。

递归程序避免覆盖最优解的几个技巧：

- 代码逻辑本身保证不会覆盖，见官方题解
- 用全局变量保存解，判断是否已经被赋值了
- 递归中子函数通过返回值告知父函数是否已经找到解，若找到，父函数直接返回子函数的解即可，是一种将最优解层层上报的感觉

```python
class Solution:
    def lowestCommonAncestor(self, root, p, q):
        if not root or root == p or root == q: return root

        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if not left:
            return right
        elif not right:
            return left
        else:
            return root
```

类似题目：
- [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
- 有没有多叉树中一组节点的公共祖先问题啊？

## 其它
### 丑数

这题练习的重点在于：用堆解法后如何分析出时空复杂度？

## 最优连续子串

这些题共同的解题思路：先用for(end)for(start)双循环枚举，然后可以启发出单循环算法（本质是一种动态规划）。注意一般我们会自然而然地写出for(start)for(end)的双循环形式，但这种形式很难启发出单循环算法。

单循环算法是在外层循环中提炼出足够多的“先验知识”，从而无需执行内层循环。“先验知识”可能是简单的number，也可能是复杂的数组、集合等等。

力扣题目（由易到难）：53、152、560、1371、32

### [力扣53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

### 力扣152. 乘积最大子数组

### 力扣560. 和为K的子数组

这题不是找最优子串，而是找出子串的数量，但思路是一样的，所以也归类在这边。
这题的“先验知识”比较复杂是：累和+字典计数。

### 力扣1371. 每个元音包含偶数次的最长子字符串

这题的“先验知识”用到了状态压缩的技巧，利用位运算将状态压缩到一个整数中。

### 力扣32. 最长有效括号
这题的“先验知识”是数组，而且每次遍历都需要对“先验知识”进行“统筹优化”，因此比较难。


## 滑动窗口
滑动窗口和双指针一样，都是对暴力算法的优化，少枚举了很多区间。它在迭代的过程中维护L、R两个指针，每次迭代只会移动L或者R。

什么样的问题可以用滑动窗口来解决？

- 新问题可在原问题的基础上“增量”计算得到
- 可以根据当前问题的状态判断下一问题是移动L指针还是R指针（决策单调性）

为什么滑动窗口算法是正确的？对理论感兴趣的同学可以查阅「决策单调性」相关的资料。

### LeetCode 3. 无重复字符的最长子串
### LeetCode 76. 最小覆盖子串
### LeetCode 209. 长度最小的子数组
注意循环终止条件的设定，过早终止循环会漏解。
注意窗口区间语义约定，左闭右开or左闭右闭？虽然左闭右开有良好的语义（两数相减刚好为窗口长度），但左闭右开需要不断判断右边界是否越界常数时间更大。

### LeetCode 424. 替换后的最长重复字符
### LeetCode 438. 找到字符串中所有字母异位词
### LeetCode 567. 字符串的排列
