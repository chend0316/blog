# 数据结构

## 哈希
应用场景：
- 加密
- 索引
- 缓存

解决哈希冲突:
- 开放寻址法: 线性探测法、二次探测法、再散列法
- 拉链法

哈希函数的实现:
- 工业界著名的: MD5、SHA、CRC
- 直接定址法
- 除留余数法，要选一个较大的素数作为除数
- 一致性哈希，可以避免扩容时产生大量数据搬移
- 如果自己设计哈希算法，原则就是要尽可能随机且均匀

当需要删除元素的时候，开放寻址法不能直接删除元素，而是要做特殊处理 (标记为已删除，而不是真正删除元素)。

### 扩容
当装载因子接近 1 的时候，开放寻址法速度降低。当装载因子远大于 1 时，拉链法会退化成为链表。扩容可以降低装载因子，但扩容后大量数据需要移动，这会导致分布式缓存场景下大量节点出现缓存击穿，[一致性哈希](https://en.wikipedia.org/wiki/Consistent_hashing)算法可以缓解这个问题。


### 语言内置的哈希表
[java.util.Map](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html) 是 Java 内置的一个接口，最常见的实现是：`HashMap`、`TreeMap`。在 Java 中，每个对象都有 hashCode() 方法，自定义的数据类型可以根据业务特点重写 `Object.hashCode()` 方法。

JavaScript 的对象本身就可以当做哈希表使用：`var hash = {};`，ES6 新增了一个专门做哈希表的类：`var hash = new Map();`

Python 的 `dict` 就是哈希表。
- 初始化: `hash = dict()`
- 使用字面量初始化: `hash = {}`
- 添加元素: `hash['a'] = 123`
- 删除元素: `del hash['a']`
- 判断 key 是否存在: `'a' in hash`
- 获取哈希表的大小: `len(hash)`

## 二叉树
二叉树一般用链式存储法来存储，每个节点有 left、right 两个指针。完全二叉树可以用顺序存储法来存储，常用于二叉堆的场景。

### 二叉搜索树
在讨论二叉搜索树时，通常是指没有重复节点的情况。删除节点操作中，如果待删节点有两个子节点就会比较复杂。还有一种取巧的删除方法，就是将节点标记为已删除，而不是真正去删除这个节点。

如果要支持重复数据的二叉搜索树。一种偷懒的方法是将每个节点换成链表。另一种更正经的方法不好描述，我这边先不写了。

### 平衡二叉搜索树
