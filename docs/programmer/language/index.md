# 编程语言理论

## 基础
### 变量
多数语言的变量都分两种：变量、常量。

Rust 语言分了三种，这里篇幅有限，不详述。

### 类型
#### 类型注解、类型推断
C++、Java 更常用类型注解，Rust、TypeScript 更常用类型推断。

#### 元组、数组
底层语言 (C/C++、Rust) 的数组是定长的，上层语言 (Java、Python、JavaScript) 的数组是变长的。

Rust 语言中，元组和数组的区别是：数组元素必须统一类型，元组元素不需要统一类型。

底层语言 (C、C++) 不检查数组越界，上层语言 (Java、Python) 能够捕获数组越界异常。有一些语言 (JavaScript) 使用 Map 充当数组，因此没有越界问题。Rust 作为底层语言，也能捕获数组越界异常，还是很优秀的。

#### 强类型和弱类型
1974年，Liskov和Zilles提出强类型语言的概念

> 在强类型语言中，当一个对象从调用函数传递到被调用函数时，其类型必须与被调用函数中声明的类型兼容

但是这个解释很泛，也不容易理解，后人给出了更具体的解释：在强类型语言中，变量的类型不能被改变。

例如Java是强类型语言：
```java
class C {
    public static void main(String[] args) {
        int x =1;
        char z = 'a';
        x = z;  // 这里Java会将'a'的ASCII码传递给x，x的类型仍然是int
    }
}
```

#### 静态类型和动态类型
静态类型语言：在编译阶段确定变量的类型

动态类型语言：在运行阶段确定变量的类型

```js
class C {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

function add(a, b) {  // js在编译的时候并不知道a和b的类型
    return a.x + a.y + b.x + b.y;
}
```

```cpp
class C {
public:
    int x;
    int y;
}

int add(C a, C b) {  // c++在编译的时候就知道a和b的类型
    return a.x + a.y + b.x + b.y;
}
```

静态类型语言在编译阶段就能够确定属性的偏移量：
- 编译阶段就确定了属性的偏移量
- 运行阶段直接根据偏移量来访问
- 所有对象共享相同的偏移量

而动态类型语言编译时无法确定属性偏移量：
- 在运行时才知道偏移量
- 需要额外空间维护属性名和偏移量之间的映射
- 每个对象的偏移量都不相同

## 堆、栈
### 堆（Heap）
在堆上分配内存也叫做动态内存分配，这比较灵活。分配之后需要手工释放，否则就会造成内存泄漏。

在 C++ 标准中，更准确的叫法是自由存储区（free store），但通常它的底层实现也是堆，所以区分自由存储区和堆的意义不大。

C 语言使用 `malloc()` 分配堆空间，使用 `free()` 释放堆空间。

有些语言使用 new 这样的关键字分配内存：
- C++：`auto list = new std::vector<int>();`
- Java：`ArrayList<int> list = new ArrayList<int>();`

有些语言把 new 关键字省略了：
- Python：`lst = list()`

不管是哪种语言，都可能牵涉到三个操作： 
1. 分配一个某大小的内存块
2. 释放一个之前分配的内存块
3. 进行垃圾收集，释放不再使用的内存块

C++ 通常会做上面的操作 1 和 2。Java 会做上面的操作 1 和 3。而 Python 会做上面的操作 1、2、3。这是语言的特性和实现方式决定的。

上面这三个操作看似简单，实际上水很深。这里简单列举几个堆分配器要解决的问题：
- 分配内存时需要找到最合适的内存块，避免过多的内存碎片
- 实际分配的内存通常会比申请的大，而且地址是对齐的
- 释放内存时要考虑合并连续未使用的内存块
- 垃圾回收是最复杂的，可单独作为一门研究生课程，这里不展开介绍

阅读材料：
- 《CSAPP》9.9节

### 栈（Stack）内存管理
局部变量存放在栈上，栈的分配和释放都非常简单，只要移动栈顶指针即可。栈的工作原理决定它天生不存在内存碎片和内存泄漏的情况。

阅读材料：
- 《CSAPP》3.7节，介绍了函数调用栈
- 《C专家编程》6.12节，介绍了 CMU 的学生利用栈“作弊”的轶事
